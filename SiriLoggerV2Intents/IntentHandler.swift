import Intents

// The class name `LogV2IntentHandling` is generated by Xcode
// based on your "Intent Name" `LogV2` in the .intentdefinition file.
class IntentHandler: INExtension, LogV2IntentHandling {
    
    override func handler(for intent: INIntent) -> Any {
        guard intent is LogV2Intent else {
            // This should not happen if INIntentsSupported is correctly configured.
            fatalError("Unhandled intent type: \(intent)")
        }
        return self
    }
    
    // MARK: - LogV2IntentHandling
    
    // This method is called by Siri to resolve the 'message' parameter.
    // If the user invokes the intent like "Hey Siri, using SiriLoggerV2, Log Entry"
    // (without providing a message), Siri will use this to ask for the message.
    func resolveMessage(for intent: LogV2Intent, with completion: @escaping (INStringResolutionResult) -> Void) {
        if let message = intent.message, !message.isEmpty {
            print("INTENT_HANDLER: Resolving message - success with: \"\(message)\"")
            completion(INStringResolutionResult.success(with: message))
        } else {
            print("INTENT_HANDLER: Resolving message - needs value (will prompt user)")
            // This tells Siri to ask the user for the message using the prompt
            // you defined in the .intentdefinition file for the 'message' parameter.
            completion(INStringResolutionResult.needsValue())
        }
    }
    
    // This method is called after all parameters (just 'message' in our case) are resolved.
    func handle(intent: LogV2Intent, completion: @escaping (LogV2IntentResponse) -> Void) {
        guard let message = intent.message, !message.isEmpty else {
            print("INTENT_HANDLER: Handle - message is nil or empty. This shouldn't happen if resolveMessage worked.")
            let response = LogV2IntentResponse(code: .failure, userActivity: nil)
            completion(response)
            return
        }
        
        print("INTENT_HANDLER: Handling intent with message: \"\(message)\"")
        
        // TODO: Re-enable SharedUserDefaults saveLastEvent(message) if App Groups become available.
        // For now, we proceed directly to the POST request.
        print("INTENT_HANDLER: (Skipping UserDefaults save for now)")
        
        sendEventToServer(message: message) { success, errorDescription in
            if success {
                print("INTENT_HANDLER: Successfully POSTed message to server.")
                let response = LogV2IntentResponse(code: .success, userActivity: nil)
                completion(response)
            } else {
                print("INTENT_HANDLER: Failed to POST message. Error: \(errorDescription ?? "Unknown error")")
                let response = LogV2IntentResponse(code: .failure, userActivity: nil)
                // To provide more detail to Siri, you'd configure response templates
                // in the .intentdefinition file for failure.
                completion(response)
            }
        }
    }
    // In SiriLoggerV2Intents/IntentHandler.swift
    
    private func sendEventToServer(message: String, completion: @escaping (Bool, String?) -> Void) {
        // IMPORTANT: Replace 'your-mac-hostname-or-ip' with your Mac's actual local IP address.
        // Ensure your Mac and iPhone are on the same Wi-Fi network.
        let serverBaseURL = "http://adams-macbook-air:4000/command" // <<-- UPDATE THIS IP
        
        // URL-encode the message to make it safe for a query parameter
        guard let encodedMessage = message.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) else {
            print("INTENT_HANDLER: Failed to URL-encode message.")
            completion(false, "Failed to prepare message for server (encoding).")
            return
        }
        
        guard let url = URL(string: "\(serverBaseURL)?message=\(encodedMessage)") else {
            print("INTENT_HANDLER: Invalid server URL constructed.")
            completion(false, "Invalid server URL.")
            return
        }
        
        print("INTENT_HANDLER: Preparing to send GET request to \(url.absoluteString)")
        
        var request = URLRequest(url: url)
        request.httpMethod = "GET" // Changed from POST to GET
        // No need for Content-Type header or httpBody for a simple GET
        
        request.timeoutInterval = 10 // Optional: 10 seconds
        
        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("INTENT_HANDLER: Network request error: \(error.localizedDescription)")
                completion(false, "Network error: \(error.localizedDescription)")
                return
            }
            
            guard let httpResponse = response as? HTTPURLResponse else {
                print("INTENT_HANDLER: Invalid response from server (not HTTPURLResponse).")
                completion(false, "Invalid response from server.")
                return
            }
            
            print("INTENT_HANDLER: Received server response with status code: \(httpResponse.statusCode)")
            if (200...299).contains(httpResponse.statusCode) {
                // Optional: Log server response body for debugging
                if let data = data, let responseString = String(data: data, encoding: .utf8) {
                    print("INTENT_HANDLER: Server response data: \(responseString)")
                }
                completion(true, nil)
            } else {
                var errorMsg = "Server error (Status code: \(httpResponse.statusCode))."
                if let data = data, let responseBody = String(data: data, encoding: .utf8), !responseBody.isEmpty {
                    errorMsg += " Response: \(responseBody)"
                }
                print("INTENT_HANDLER: \(errorMsg)")
                completion(false, errorMsg)
            }
        }
        task.resume()
    }
}

